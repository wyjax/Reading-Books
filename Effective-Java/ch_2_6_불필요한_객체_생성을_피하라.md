## Chapter 2.6 불필요한 객체 생성을 피하라



>똑같은 객체를 여러 번 생성하는 것보다 같은 객체를 재사용하는 것이 효율적인 측면에서 좋을 때가 많다. 재사용은 세련되고 빠르다(객체의 생성과 소멸에 드는 비용이 적기 때문). 



##### 하지 말아야할 극단적인 예

```java
String s = new String("wyjax"); // 따라하지 말자ㅋㅋㅋ
```

위의 문장은 실행이 될 때마다 객체가 생성되어 진다. (쓸데없는 행위) 

```java
String s = "wyjax"; // 이것은 위의 코드와 똑같다. 그니깐 괜히 위처럼 쓰지말고 아래처럼 써라
```

이 방식을 사용하면 같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다.

생성자 대신 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 줄일 수 있다. Boolean(String) 대신에 Boolean.valueOf(String) 팩터리 메서드를 사용하는 것이 좋다. 왜냐하면 생성자는 매 항상 객체를 만들지만 valueOf 정적 팩터리 메서드는 그렇지 않기 때문이다.

> 불변객체 뿐만 아니라 가변객체여도 변경이 되지 않을 것임을 안다면 재사용 할 수 있다.



객체를 생성도 생성이지만 객체 중에서도 생성비용이 엄청난 친구도 있다.

경험상 이야기하면 java 정규식 관련 메서드를 작성한 적이 있는데. Pattern에서 Matcher를 구하는 메서드가 있는데 거기에서 성능이 엄청 느려지는 것을 알았다. (후에는 Matcher에서 재사용하는 방식을 채택ㅎㅎ)

```java
// 나도 이와 같은 경험이 있다ㅋㅋㅋ 이 책을 빨리 읽었더라면 이런 일은 없었을텐데
static final REGEX = "...대충 정규식있다는 뜻...";

static boolean isRomanNumeral(String s) {
    return s.matches(REGEX);
}
```

이 방식에서 문제는 s.matches() 에서 문제가 발생한다. 이 메서드는 정규표현식이 맞는지 확인하는 메서드이고 쉽지만, 성능이 중요한 상황에서는 반복해서 사용하기에 적합한 방법은 아니다.

내부에서 만드는 Pattern 인스턴스는, 유한상태 머신을 만들기 때문에 인스턴스 비용이 높다. 여기에서 성능을 개선하려면 Pattern에 관해서 캐싱을 해두면 된다.

```java
public class RomanNumberals {
    private static final Pattern ROMAN = Pattern.compile("착한 사람한테 보이는 정규식");
    
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
// 이러면 성능이 엄청 개선된다. 나 또한 그럤다. 로그를 분석하는 거였는데 성능이 진짜 많이 개선됐다... 거의 2배
```

이 책에서는 예제를 돌렸는데 6.5배가 빨라졌단다...ㅋㅋ 대단쓰



불필요한 객체를 만드는데는 오토박싱을 또 예로 들 수 있다. 오토박싱은 기본 타입과 랩퍼 클래스 타입 사이의 변환을 말하는 것이다. 오토박싱 <---> 오토 언박싱



```java
privatre static long sum() {
    Long sum = 0L;
    // long sum = 0K; 이렇게 하면 성능이 높아진다. 왜? 오토박싱이 없어지기 때문에
    
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i; // long을 Long으로 변환하는 과정에서 불필요한 Long 객체가 생성됨
    }
    
    return sum;
}
```

박싱된 기본 타입(**Long**)보다는 그냥 기본 타입(**long**)을 사용하고 의도치 않은 오토박싱이 숨어들지 않게 하자 !

이번 아이템을 통한 교훈 중에서 주의해야 할 점 ! "객체 생성은 비싸니 피해야 한다"로 오해하지 말아야 한다. 요즘같은 JVM은 별다른 일을 하지 않는 작은 객체를 생성하고 소멸시키는 일은 크게 부담되지 않는다. 다만 프로그램의 ㅁ여확성, 간결성 기능을 위해서 객체를 추가로 생성하는 것이면 일반적으로 좋은 일이다. 



#### 방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다!!!!!!!!!1