#### 1. 협력하는 객체들의 공동체

객체지향에서 제일 중요한 것은 상속, 클래스가 아니고 역할, 협력, 책임이다. 이 책의 저자는 이 3가지의 예를

카페테리아로 설명을 했다. 각각의 역할들은 손님, 바리스타, 캐시어로 역할을 나눴고 바리스타와 캐시어가 서로 협력하에

각자의 역할에 맞는 책임을 가지고 커피를 만들고 손님에게 내어주었다. 



##### 역활은 유연하고 재사용 가능한 협력 관계를 구축하는 데 중요한 설계 요소다.



##### 상태와 행동을 함께 지닌 자율적인 객체

객체를 상태, 행동을 함께 지닌 실체라고 한다.

객체가 자율적인 존재로 남기  위해서는 필요한 행동과 상태를 함께 가지고 있어야 한다.



##### 객체를 지향하라

객체지향은 객체를 주체로 생각하여야 한다. 클래스는 객체를 만드는 메커니즘에 불과하다. 그렇기 때문에 객체지향을 클래스로만 알고 있으면 안될 것 같다. 클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라. 객체지향은 객체를 지향하는 것이지 클래스가 핵심이 되는 것이 아니다.



### 이상한 나라의 객체

객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내재된 복잡성을 관리하려고 한다. 객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다.

##### 객체지향 패러다임의 목적

객체지향의 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는 것, 그렇기 때문에 소프트웨어의 세계에서 살아가는 객체는 현실 세계에 존재하는 객체와는 전혀 다른 모습으로 존재하고 있다.



##### 이상한 나라 앨리스 이야기

엘리스는 케이크를 먹으면 키가 커지고, 버섯을 먹으면 키가 작아진다. 이러한 과정은 문을 통과하기 위해 자신의 키를 계속적으로 변화를 시킨 것이다. 앨리스는 키가 커지고, 작아지는 것을 하기 위해서는 버섯을 먹는 '행동'을 통해서 '상태'를 변화를 시켰다.

객체의 다양한 특성을 효과적으로 설명하기 위해서는 객체를 상태, 행동, 실별자를 지닌 실체로 보는 것이 효과적

##### 상태

객체는 다른 객체에 상태에 직접적으로 접근할 수도 없고, 상태를 변경할 수도 없다. 객체의 상태를 변경하기 위해서는 상태를 가지고 있는 객체가 직접 변경을 해야 한다. 이렇게 하는 것이 객체의 자율성을 보장하는 것

1. 객체는 상태를 가지며 상태는 변경 가능하다.
2. 객체의 상태를 변경시키는 것은 객체의 행동이다. 
3. 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.



객체를 설계할 때는 객체에서 사용되는 상태에 초점을 맞추게 되면 상태가 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 노출되어버릴 확률이 높아진다.



헤리 백의 지하철 노선도를 보고나서 지하철 노선도를 예를 들어 객체를 설계할 때는 지형정보같은 것들은 배제하고 역과 역사이가 어떻게 되어 있고, 환승은 어떤식으로 되어지는지 한 눈에 파악할 수 있도록 직관적으로 설계를 하면 좋을 것 같다.



##### 이 책에서 말하는 추상화의 정의

어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.

> 추상화의 목적은 복잡하게 얽혀있는 이해관계를 이해하기 쉬운 수준으로 단순화하는 것이다.
>
> \> 나는 지금까지 단순히 공통적인 것을 묶으려고만 생각하고 객체를 설계했던거 같다. 복잡한 것을 이해하기 쉬운 수준으로 변경하려고 노력하진 않았던거 같음

앨리스에서는 신하, 여왕, 왕을 한 눈에 보고도 구별할 수 있게 되어 있다. 이렇게 신하, 여왕, 왕 등을 한 눈에 알아보기 쉽게 설계하는 것이 객체지향 패러다임에서는 객체라고 한다.

정원사, 왕, 신하는 모두 통틀어서 '트럼프'라고 지칭할 수 있다. 이 트럼프라는 개념은 정원사, 왕을 통틀어서 묶은 추상화의 개념으로 말할 수 있다. > 공통점만을 강조!



행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야 하는 데이터가 아니라 객체가 외부에 제공해야 하는 행동을 먼저 생각해야 한다. > 그렇기 위해서는 먼저 객체가 외부에 제공하는 책임을 먼저 결정하고 그 책임을 수행하는데 적합한 데이터를 나중에 결정한 후 데이터를 책임을 수행하는데 필요한 외부 인터페이스 뒤로 캡슐화 해야 한다.

> 데이터를 먼저 결정하고 객체의 책임을 결정하는 방법은 유연하지 못한 설계를 낳을 수 있다. 이렇게 말하는 '책임 주도 설계'는 '데이터 주도 설계'의 단점을 해결하기 위해서 고안되었다



##### 슈퍼타입과 서브타입

트럼프 > 슈퍼타임

트럼프인간 > 서브타입

```java
class Trumph {}
// 앨리스는 트럼프 인간임에도 불구하고 '트럼프'로만 불렀다. 트럼프인간에서 걸어다니는 특성을 배제한 채 공통점만을 강조함으로써 블필요한 특성을 배제하고 좀 더 포괄적인 의미로 트럼프로 일반화했다.
// 트럼프는 트럼프인간보다 상위 클래스의 개념으로 볼 수 있다.
class TrumphHuman {}
```



##### 동적 모델과 정적 모델

정적 모델을 애플리케이션이 실행되기 전에 사용되어지는 객체를 보는 관점이고 class를 통하여 모델링한다
동적 모델은 애플리케이션이 실행되었을 때 보여지는 것이다.

##### 클래스

객체지향 프러그레밍에서ㅏ정적인 모델은 클래스를 이용하여 구현한다. 따라서 타입을 구현하기 위해서 클래스를 활용한다.
타입과 클래스는 다르다. 타입을 객체를 분류할 수 있는 개념이고, 클래스는 타입을 구현할 수 있는 여러 메커니즘 중 하나



##### 협력

요청은 응답을 낳고, 응답은 또 요청을 하고 응답을 낳는다. 이렇게 연쇄적인 요청과 응답이 일어나고, 객체들은 각각의 책임을 지는 자리에서 협력하여 애플리케이션을 돌아가게 해야 한다.



##### 책임

객체지향에서 객체가 요청을 받았을 때 적절하게 행동을 해야하는 경우를 책임을 가진다고 한다. 앨리스의 내용에서 왕은 모자장수에게 재판에 응하라고 했기에 재판에 응하는 책임을 가져야하고, 증언을 하는 책임을 가진다. 
 책임은 객체지향 설계의 가장 중요한 재료다. 책임을 어떻게 구현할 것인가하는 문제는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지 않다. 객체와 책임이 이리저리 부유하는 상황에서 성급하게 구현에 띄어드는 것은 변경에 취약하고 다양한 협력에 참여할 수 없는 비자율적인 객체를 낳게 된다.

##### 객체의 책임

1. 무엇을 알고 있느냐
2. 무엇을 할 수 있느냐

- 하는 것
  - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

> 메시지 전송 : 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것 
>
> 송신자 - 요청을 보내는 쪽, 수신사 - 요청을 받는 쪽 (응답까지)



##### 역할

앨리스의 이야기에서 왕은 재판관이라는 역할을 수행하고, 토끼는 증인을 불러오는 역할, 모자장수는 증언을 하는 역할을 맡는다. 결론적으로 어떤 객체가 수행하는 책임의 잡합은 객체가 협력 안에서 수행하는 역할을 암시한다. 이러한 객체의 역할은 나중에도 재사용이 가능하고 유연한 객체지향 설계를 하는 매우 중요한 구성요소이다.



##### 앨리스 이야기에서 역할에 관해서 코딩,,

```java
interface Judger {
  Result excuteJudge(Rabbit rabbit) {
		Witnesser wit = rabbit.callWitness();
    WitnessResult res = witness.talkWitness();
  }
}

class King implements Judger {}
class Queen implements Judger {}

class Rabbit {
  public Witness callWitness();
}

class Witnesser {
  WitnessResult talkWitness();
}
```

##### 대체 가능성

역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.



#### 객체의 모양을 결정하는 협력



##### 객체지향에 대한 선입견

1. 객체는 데이터를 저장하기 위해서 존재한다.
   - 데이터는 단지 객체가 행위를 하는데 필요한 재료일 뿐이다.
2. 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다는 것이다. 클래스는 단지 객체지향을 표현하는 매커니즘 중에 하나이다. 

객체지향을 설계할 때에는 클래스를 중심으로 설계하지 말고 협력한다는 사실을 두고 클래스를 설계해야 한다. 

객체가 존재하는 이유는 데이터를 저장시키기 위해 존재하는 것이 아니라 데이터는 단지 객체가 행위를 수행하는데 필요한 재료일 뿐이다. 



재판관, 증인의 객체를 만든다고 했을 때, 재판관과 증인사이에서 이루어지는 행동을 먼저 파악한다. 그 후에 행동에 필요한 데이터를 각각 만들어준다. 행위를 파악하기 전에는 객체가 가지는 책임에 대해서 고민해야 한다. 객체가 해야하는 협력을 정의하고 난 후에 데이터와 행위를 설계한다.

##### 객체 설계의 품질을 높이는 법 : 협력에 필요한 책임을 먼저 결정하고 객체에게 책임을 할당하는 것을 잘해야함

책임과 협력의 관점에서 객체를 바라보는 훈련이 필요한 것 같음



##### 협력의 관점에서 애플이케이션을 설계하는데 유용한 세가지 방법

1. **책임-주도 설계** (responsibility driven design)
2. **디자인 패턴** (design pattern)
3. **테스트 주도 개발** (test driven development) - 테스트 주도 개발의 핵심은 테스트가 목적이 아니고 설계의 목적을 가지고 있다.



##### 워프스브록 - 책임 주도 설계 (Responsibility Driven Design)

객체의 책임을 중심으로 시스템을 구축하는 설계 방법이다. 시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 객체에게 할당된다. 객체가 책임을 수행하는 도중에 수행할 수 없는 난관에 봉착하면 대신에 수행할 수 있는 객체를 찾은 다음 그 객체에게 작업 수행을 요청한다. 이렇게 객체가 객체에게 수행을 요청하는 그림을 그림으로써 객체사이의 협력 관계가 형성된다.

1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
2. 1시스템 책임 -> N개의 작은 책임으로 분할
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
4. 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 이로써 다른 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.



#### 자율적인 책임

설계의 품질을 좌우하는 책임, 요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다. 따라서 자율적인 객체란 스스로의 의지와 판단에 따라 맡은 책임을 수행하는 객체를 의미한다. 

객체지향 애플리케이션을 설계하는 가장 널리 알려진 방법을 책임-주도 설계라고 부르는데, 이유는 적절한 책임의 선택이 전체 설계의 방향을 결정하기 때문이다.



객체가 자율적으로 일을 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 한다. 책임이 자율적이지 않다면 객체가 아무리 발버둥쳐도 자율적으로 책임을 수행하기 어렵다



##### 다형성

다형성은 역할, 책임, 협력과 깊은 관련이 있다. 서로 다른 객체들이 다형성을 만족시킨다는 것이 객체들이 동일한 책임을 공유한다는 것을 의미한다. 다형성에서 중요한 것은 메시지 송신자의 관점이다.



##### 구현

객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현이다. 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함된다.

























