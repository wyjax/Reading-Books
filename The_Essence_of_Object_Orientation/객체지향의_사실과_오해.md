#### 1. 협력하는 객체들의 공동체

객체지향에서 제일 중요한 것은 상속, 클래스가 아니고 역할, 협력, 책임이다. 이 책의 저자는 이 3가지의 예를

카페테리아로 설명을 했다. 각각의 역할들은 손님, 바리스타, 캐시어로 역할을 나눴고 바리스타와 캐시어가 서로 협력하에

각자의 역할에 맞는 책임을 가지고 커피를 만들고 손님에게 내어주었다. 



##### 역활은 유연하고 재사용 가능한 협력 관계를 구축하는 데 중요한 설계 요소다.



##### 상태와 행동을 함께 지닌 자율적인 객체

객체를 상태, 행동을 함께 지닌 실체라고 한다.

객체가 자율적인 존재로 남기  위해서는 필요한 행동과 상태를 함께 가지고 있어야 한다.



##### 객체를 지향하라

객체지향은 객체를 주체로 생각하여야 한다. 클래스는 객체를 만드는 메커니즘에 불과하다. 그렇기 때문에 객체지향을 클래스로만 알고 있으면 안될 것 같다. 클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라. 객체지향은 객체를 지향하는 것이지 클래스가 핵심이 되는 것이 아니다.



### 이상한 나라의 객체

객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내재된 복잡성을 관리하려고 한다. 객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다.

##### 객체지향 패러다임의 목적

객체지향의 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는 것, 그렇기 때문에 소프트웨어의 세계에서 살아가는 객체는 현실 세계에 존재하는 객체와는 전혀 다른 모습으로 존재하고 있다.



##### 이상한 나라 앨리스 이야기

엘리스는 케이크를 먹으면 키가 커지고, 버섯을 먹으면 키가 작아진다. 이러한 과정은 문을 통과하기 위해 자신의 키를 계속적으로 변화를 시킨 것이다. 앨리스는 키가 커지고, 작아지는 것을 하기 위해서는 버섯을 먹는 '행동'을 통해서 '상태'를 변화를 시켰다.

객체의 다양한 특성을 효과적으로 설명하기 위해서는 객체를 상태, 행동, 실별자를 지닌 실체로 보는 것이 효과적

##### 상태

객체는 다른 객체에 상태에 직접적으로 접근할 수도 없고, 상태를 변경할 수도 없다. 객체의 상태를 변경하기 위해서는 상태를 가지고 있는 객체가 직접 변경을 해야 한다. 이렇게 하는 것이 객체의 자율성을 보장하는 것

1. 객체는 상태를 가지며 상태는 변경 가능하다.
2. 객체의 상태를 변경시키는 것은 객체의 행동이다. 
3. 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.



객체를 설계할 때는 객체에서 사용되는 상태에 초점을 맞추게 되면 상태가 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 노출되어버릴 확률이 높아진다.



헤리 백의 지하철 노선도를 보고나서 지하철 노선도를 예를 들어 객체를 설계할 때는 지형정보같은 것들은 배제하고 역과 역사이가 어떻게 되어 있고, 환승은 어떤식으로 되어지는지 한 눈에 파악할 수 있도록 직관적으로 설계를 하면 좋을 것 같다.



##### 이 책에서 말하는 추상화의 정의

어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.

> 추상화의 목적은 복잡하게 얽혀있는 이해관계를 이해하기 쉬운 수준으로 단순화하는 것이다.
>
> \> 나는 지금까지 단순히 공통적인 것을 묶으려고만 생각하고 객체를 설계했던거 같다. 복잡한 것을 이해하기 쉬운 수준으로 변경하려고 노력하진 않았던거 같음

앨리스에서는 신하, 여왕, 왕을 한 눈에 보고도 구별할 수 있게 되어 있다. 이렇게 신하, 여왕, 왕 등을 한 눈에 알아보기 쉽게 설계하는 것이 객체지향 패러다임에서는 객체라고 한다.

정원사, 왕, 신하는 모두 통틀어서 '트럼프'라고 지칭할 수 있다. 이 트럼프라는 개념은 정원사, 왕을 통틀어서 묶은 추상화의 개념으로 말할 수 있다. > 공통점만을 강조!



행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야 하는 데이터가 아니라 객체가 외부에 제공해야 하는 행동을 먼저 생각해야 한다. > 그렇기 위해서는 먼저 객체가 외부에 제공하는 책임을 먼저 결정하고 그 책임을 수행하는데 적합한 데이터를 나중에 결정한 후 데이터를 책임을 수행하는데 필요한 외부 인터페이스 뒤로 캡슐화 해야 한다.

> 데이터를 먼저 결정하고 객체의 책임을 결정하는 방법은 유연하지 못한 설계를 낳을 수 있다. 이렇게 말하는 '책임 주도 설계'는 '데이터 주도 설계'의 단점을 해결하기 위해서 고안되었다



##### 슈퍼타입과 서브타입

트럼프 > 슈퍼타임

트럼프인간 > 서브타입

```java
class Trumph {}
// 앨리스는 트럼프 인간임에도 불구하고 '트럼프'로만 불렀다. 트럼프인간에서 걸어다니는 특성을 배제한 채 공통점만을 강조함으로써 블필요한 특성을 배제하고 좀 더 포괄적인 의미로 트럼프로 일반화했다.
// 트럼프는 트럼프인간보다 상위 클래스의 개념으로 볼 수 있다.
class TrumphHuman {}
```



##### 동적 모델과 정적 모델

정적 모델을 애플리케이션이 실행되기 전에 사용되어지는 객체를 보는 관점이고 class를 통하여 모델링한다
동적 모델은 애플리케이션이 실행되었을 때 보여지는 것이다.

##### 클래스

객체지향 프러그레밍에서ㅏ정적인 모델은 클래스를 이용하여 구현한다. 따라서 타입을 구현하기 위해서 클래스를 활용한다.
타입과 클래스는 다르다. 타입을 객체를 분류할 수 있는 개념이고, 클래스는 타입을 구현할 수 있는 여러 메커니즘 중 하나



##### 협력

요청은 응답을 낳고, 응답은 또 요청을 하고 응답을 낳는다. 이렇게 연쇄적인 요청과 응답이 일어나고, 객체들은 각각의 책임을 지는 자리에서 협력하여 애플리케이션을 돌아가게 해야 한다.



##### 책임

객체지향에서 객체가 요청을 받았을 때 적절하게 행동을 해야하는 경우를 책임을 가진다고 한다. 앨리스의 내용에서 왕은 모자장수에게 재판에 응하라고 했기에 재판에 응하는 책임을 가져야하고, 증언을 하는 책임을 가진다. 
 책임은 객체지향 설계의 가장 중요한 재료다. 책임을 어떻게 구현할 것인가하는 문제는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지 않다. 객체와 책임이 이리저리 부유하는 상황에서 성급하게 구현에 띄어드는 것은 변경에 취약하고 다양한 협력에 참여할 수 없는 비자율적인 객체를 낳게 된다.

##### 객체의 책임

1. 무엇을 알고 있느냐
2. 무엇을 할 수 있느냐

- 하는 것
  - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

> 메시지 전송 : 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것 
>
> 송신자 - 요청을 보내는 쪽, 수신사 - 요청을 받는 쪽 (응답까지)



##### 역할

앨리스의 이야기에서 왕은 재판관이라는 역할을 수행하고, 토끼는 증인을 불러오는 역할, 모자장수는 증언을 하는 역할을 맡는다. 결론적으로 어떤 객체가 수행하는 책임의 잡합은 객체가 협력 안에서 수행하는 역할을 암시한다. 이러한 객체의 역할은 나중에도 재사용이 가능하고 유연한 객체지향 설계를 하는 매우 중요한 구성요소이다.



##### 앨리스 이야기에서 역할에 관해서 코딩,,

```java
interface Judger {
  Result excuteJudge(Rabbit rabbit) {
		Witnesser wit = rabbit.callWitness();
    WitnessResult res = witness.talkWitness();
  }
}

class King implements Judger {}
class Queen implements Judger {}

class Rabbit {
  public Witness callWitness();
}

class Witnesser {
  WitnessResult talkWitness();
}
```

##### 대체 가능성

역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.



#### 객체의 모양을 결정하는 협력



##### 객체지향에 대한 선입견

1. 객체는 데이터를 저장하기 위해서 존재한다.
   - 데이터는 단지 객체가 행위를 하는데 필요한 재료일 뿐이다.
2. 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다는 것이다. 클래스는 단지 객체지향을 표현하는 매커니즘 중에 하나이다. 

객체지향을 설계할 때에는 클래스를 중심으로 설계하지 말고 협력한다는 사실을 두고 클래스를 설계해야 한다. 

객체가 존재하는 이유는 데이터를 저장시키기 위해 존재하는 것이 아니라 데이터는 단지 객체가 행위를 수행하는데 필요한 재료일 뿐이다. 



재판관, 증인의 객체를 만든다고 했을 때, 재판관과 증인사이에서 이루어지는 행동을 먼저 파악한다. 그 후에 행동에 필요한 데이터를 각각 만들어준다. 행위를 파악하기 전에는 객체가 가지는 책임에 대해서 고민해야 한다. 객체가 해야하는 협력을 정의하고 난 후에 데이터와 행위를 설계한다.

##### 객체 설계의 품질을 높이는 법 : 협력에 필요한 책임을 먼저 결정하고 객체에게 책임을 할당하는 것을 잘해야함

책임과 협력의 관점에서 객체를 바라보는 훈련이 필요한 것 같음



##### 협력의 관점에서 애플이케이션을 설계하는데 유용한 세가지 방법

1. **책임-주도 설계** (responsibility driven design)
2. **디자인 패턴** (design pattern)
3. **테스트 주도 개발** (test driven development) - 테스트 주도 개발의 핵심은 테스트가 목적이 아니고 설계의 목적을 가지고 있다.



##### 워프스브록 - 책임 주도 설계 (Responsibility Driven Design)

객체의 책임을 중심으로 시스템을 구축하는 설계 방법이다. 시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 객체에게 할당된다. 객체가 책임을 수행하는 도중에 수행할 수 없는 난관에 봉착하면 대신에 수행할 수 있는 객체를 찾은 다음 그 객체에게 작업 수행을 요청한다. 이렇게 객체가 객체에게 수행을 요청하는 그림을 그림으로써 객체사이의 협력 관계가 형성된다.

1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
2. 1시스템 책임 -> N개의 작은 책임으로 분할
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
4. 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 이로써 다른 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.



#### 자율적인 책임

설계의 품질을 좌우하는 책임, 요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다. 따라서 자율적인 객체란 스스로의 의지와 판단에 따라 맡은 책임을 수행하는 객체를 의미한다. 

객체지향 애플리케이션을 설계하는 가장 널리 알려진 방법을 책임-주도 설계라고 부르는데, 이유는 적절한 책임의 선택이 전체 설계의 방향을 결정하기 때문이다.



객체가 자율적으로 일을 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 한다. 책임이 자율적이지 않다면 객체가 아무리 발버둥쳐도 자율적으로 책임을 수행하기 어렵다



##### 다형성

다형성은 역할, 책임, 협력과 깊은 관련이 있다. 서로 다른 객체들이 다형성을 만족시킨다는 것이 객체들이 동일한 책임을 공유한다는 것을 의미한다. 다형성에서 중요한 것은 메시지 송신자의 관점이다.



##### 구현

객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현이다. 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함된다.

객체가 가져야할 상태와 메서드 구현은 객체 내부에 속한다. 이 부분을 수정하더라도 객체 외부에 영향을 미쳐서는 안 된다.

 ```java
 public interface Car {
   void move();
   void stop();
 }
 public class HyundaiCar implements Car {
   @Override
 	public void move() {/* 구현 */}
   @Override
   public void stop() {/* 구현 */}
 }
 // 현대자동차의 구현이 변경 된다고 하더라도 Car의 변경이 되지 않아야 한다.
 // 인터페이스와 구현의 분리는 변경에 유연하게 대응하기 위해서다
 ```



##### 3. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다

'증언하라'라는 내용의 메세지라면 어떠한 방법으로도 증명만 하면 되고 실제로도 말해도 되고, 동영상을 녹화하고서도 그것을 보여주면 된다. 책임이 자율적일수록 협력이 좀 더 유연해지고 다양한 문맥에서 재활용될 수 있고, 그렇게 된다면 설계가 유연해지고 재사용성이 높아진다.



##### 5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.

재판에서 모자 장수의 책임 1.증인석에 입장하는 것 2.증언을 하는 것 
객체가 수행하는 책임들이 자율적이면 자율적일수록 객체의 존재 이유를 명확하게 표현할 수 있다. 
객체의 책임이 자율적일수록 객체의 응집도를 높은 상태로 유지하기가 쉬워진다.

​	> 맞는 말인거 같음 객체의 자율성이 높아지면 더더 추상적이게 될텐데 그렇게 되면  여러가지로 객체의 행동이 변신할 수 있기 때문에 높은 응집도를 만들 수 있다!!

책임이 자율적일수록 협력이 이해하기 쉬워진다. 

##### 책임이 자율적이면 얻는 파급효과

1. 적절하게 '추상화'
2. '응집도' 상승
3. '결합도' 하락
4. '캡슐화 증진'
5. 인터페이스(외부)와 구현(내부) 명확해짐

위의 것들만 생각해도 객체가 유연하게 변경될 수 있고 다양하게 재활용될 수 있다.



#### 기능 설계 대 구조 설계

기능 측면의 설계 구조 측면의 설계, **훌륭한 기능**은 **훌륭한 소프트웨어**의 충분조건이고 **훌륭한 구조**는 **훌륭한 소프트웨어**의 필요조건이다. 훌륭한 구조가 필요저건이 이유는 좋은 소프트웨어가 되면서 사용자의 요구사항에 맞추어 새로운 기능을 추가하는데 도움을 주기 때문이다.

##### 설계가 어려운 이유 : 약속했던 기능을 제공하는 동시에 다음에 오는 새로운 요구사항도 받아들일 수 있어야 한다.

그렇다고 불확실한 미래의 변경을 예측하고 이를 성급하게 설계에 반영하는 것은 불필요하게 복잡한 설계를 낳을 뿐이다.

> 오늘 읽은 것 중에 제일 많이 와 닿는 부분이다. 나는 지금까지 현재의 요구사항을 만족하는 개발을 넘어 미래에 이런 일도 있을 것 같은데? 하는 생각을 조금 넣어 개발을 하곤 했고 그 결과 약간 안 좋은 설계가 된 것 같기도 하다. 책에서 말하는 것처럼 불확실한 미래는 예측하지 않는게 좋다. 그 일이 일어나지 않을 수도 있으니깐ㅎ

그럼 어떻게 해야할까? 미래에 대비하는 좋은 방법으로는 변경에 대해서 예측해서 개발하는 것이 아닌 변경을 수용만이라도 할 수 있도록 선택의 여지를 설계에 마련해 놓는 것이라고 말하고 있다. 

```java
public class Car {
  private String name;
  
  public Car(String name) {
    this.name = name;
  }
}

public class Car {
  private CarName carName;
  
  public Car(CarName carName) {
    this.carName = carName;
  }
  // car name은 string에서 다른 값으로도 변할 수 있다 name을 CarName으로 객체화시켜 변경의 여지를 준다
}
```

##### *좋은 설계는 나중에라도 변경할 수 있는 여지를 남겨 놓는 설계, 설계를 하는 목적은 나중에 설계하는 것을 허용하는 것!!*



#### 두 가지 재료: 기능과 구조

기능과 구조를 표현하기 위해 일관되게 적용할 수 있는 두 가지 기법

1. 구조는 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현함
2. 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현됨



#### 도메인 모델

모델이란? 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태. 대상을 추상화 -> 단순화시킴

멘탈모델(mental model) : 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형이다.

> 사용자가 도메인을 바라보는 관점이며 설계자가 시스템의 구조를 바라보는 관점인 동시에 소프트웨어 안에 구현된 코드의 모습 그 자체!



##### 예제: 정기예금 도메인 모델

```java
// 계좌, 예금, 이자율, 이자
public class Account {
  private String accountNumber;
  private long amount; 
}

public class Deposit {
  private LocalDate startDate;
  private LocalDate endDate;
  private DepositType type;
  private boolean isActive;
}

public class Interest {
  private long amount;
}

public class InterestRate {
  private double rate;
}

public enum DepositType {
  FIXED;
}
```



#### 불안정한 재료: 기능

##### 유스케이스

기능적 요구사항이란 시스템이 사용자에게 제공해야 하는 기능의 목록을 정리한 것이다. 그럼 왜 기능을 제공하나? => 이건 사용자가 시스템을 이용하여 이루고자, 하고자하는 목표가 있기 때문이다.

##### 일차 액터: 서비스 중 하나를 요청하는 이해관계자, 하나의 목표를 가지고 유스케이스를 시작하는 액터



#### 재료 합치기: 도메인 모델, 유스케이스, 책임 주도 설계

도메인 모델은 구조를, 유스케이스는 협력의 출발점인 시스템의 책임을 제공.

1. 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택 > sw와 코드 사이의 표현적 차이를 줄이는 첫걸음 협력을 완성 > 객체들에게 책임 할당

##### 유스케이스의 역할 > 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분해할 수 있는 출발점을 제공



##### 예제

이자계산 기능 구현

3. 예금주가 금일 기준으로 예끔을 해지할 경우 받을 수 있는 이자 계산을 요청

4. 시스템은 중도 해지시 받을 수 있는 이자를 계산하고 결과를 return

```java
// 이자 계산 클래스 다이어그램
public class TimeDeposit {
  // duration
  // closed
  void calculateInterest(when);
}
public class Account {
  private String accountNumber;
  private long amount;
  public void calculateInterest(when);
}
public class Interest {
  private long amount;
  private LocalDate paymentDate;
}
public class InterestRate {
  private double rate;
  public void createInterest(when, amount);
}
```









































































