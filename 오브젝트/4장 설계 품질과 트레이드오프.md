# 4장 설계 품질과 트레이드오프

객체지향 설계의 핵심은 역할, 책임, 협력

- 협력은 기능 구현을 위해 메시지를 주고받는 객체들 사이의 상호작용
- 책임은 객체가 다른 객체와 협력하기 위해 수행하는 행동
- 역할은 대체 가능한 책임의 집함

### 객체지향 설계 분할 기준

- 상태 중싱 분할 : 객체는 자신이 포함하고 있는 데이터를 조작하는데 필요한 오퍼레이션 정의
- 책임 중심 분할 : 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관

### 켑술화

설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 없다.

### 높은 응집도

결합도가 높은 원인은 대부분 캡슐화가 내부 구현을 노출하기 때문

```java
public class Movie {
    private Money fee;

    public Money getFee() {
        return fee;
    }
		// 캡슐화가 그대로 노출?
    pubic void setfee(Money fee) {
        this.fee = fee;
    }
}
```

### 낮은 응집도

서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말함. 그렇기 때문에 변경이 일어나면 변경과 상관없는 코드들이 영향을 받게 된다.

### 캡슐화를 지켜라

객체에게 의미있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드. 접근자가 private이라고 하더라도 수정자를 public으로 해놓는다면 캡슐화를 위반하는 코드이다.

> 내부 구현의 변경으로 인해서 다른 객체가 영향을 받는다면 캡슐화를 위반하는 것이다.
> 

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다

`올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다` 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는가는 부가적인 문제다.

안타깝게도 데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향한다. 실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다. 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출수밖에 없다.