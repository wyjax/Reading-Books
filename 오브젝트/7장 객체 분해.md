### 프로시저 추상화, 데이터 추상화

#### 추상화 매커니즘

- 프로시저 추상화 : 소프트웨어가 무엇을 해야 하는지
  - 기능분해(알고리즘 분해)
- 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지
  - 타입 추상화
  - 프로시저 추상화

### 하양식 기능 분해의 문제점

1. **시스템은 하나의 메인 함수로 구성돼 있지 않음**

   시간이 지나면 요구사항에 의해서 새로운 기능을 개발하게 된다. 모든 기능들은 규모라는 측면에서 차이가 있을수 있지만, 가능성의 측면에서는 동등하게 독립적이고 완결된 하나의 기능을 포함한다.

2. **기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.**

   기존 로직과는 아무런 상관 없는 새로운 함수의 위치를 확보해야 하기 때문에 메인 함수의 구조를 변경할 수 밖에 없다. 기존 코드 수정은 새로운 버그를 만들어낼 확률을 높임

3. **비즈니스 로직이 사용자 인터페이스와 강하게 결합된다**

   하향식 접근법은 비즈니스 로직은 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다. 결과적으로 코드 안에서 비즈니스 로직과 인터페이스 로직이 밀접하게 결합됨

   문제는.. 비즈니스 로직과 인터페이스 로직의 수정의 빈도가 차이가 난다. 그래서 인터페이스를 변경하면 비즈니스 로직에도 영향이 있다. 하향식 접근법은 근본적으로 **변경에 불안정한 아키텍처**를 낳는다.

4. 하양식 분해는 빠른 시기에 실행 순서가 고정되기 때문에 유연성과 재사용성이 저하됨

   하향식 설계는 시작하는 시점부터 시슽엠이 무엇을 해야 하는지가 아니라 어떻게 동작해야 하는지에 집중하도록 만든다. 그래서 함수들의 실행순서를 정의하는 시간 제약을 강조함

   이런 것은 재사용하기 어렵다 만든다.

5. 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다

   하향식 기능 분해의 가장 큰 문제점은 **어떤 데이터를 어떤 함수가 사용하고 있는지 추적하기 어렵다**!!

### 하향식 분해의 유용시기

하향식 아이디어는 설계각 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이함.
그렇지만 설계를 문서화하는데 적절한 방법이 좋은 구조를 설계하지 않는다

### 모듈

##### 정보 은식과 모듈

기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해해야함
외부에서 내부의 비밀에 접근하지 못하도록 커다란 방어막을 쳐서 에워쏴라. 방어막 == 퍼블릭 인터페이스

##### 감춰야할  2가지

- 복잡성: 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다. 외부에 모듈을 추상화 할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춤
- 변겨 가능성 : 변경 가능한 설계결정이 외부에 노출될 경우 실제로 변경이 발생 했을 때 파급효과가 커진다. 변경이 가능한 설계 결정은 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공

### 데이터 추상화와 추상 데이터 타입

##### 추상 데이터 타입

타입은 저장된 값에 대해 수행될 수 있는 연산의 집합을 결정하기 때문에 변수의 값이 어떻게 행동할 것이라는 걸 예측가능함

리스코프는 프로시저 추상화의 한계를 인지하고 이를 보완하기 위해 **데이터 추상화**의 개념 제안

게빙-폐쇄 원칙 (OCP) : 기존 코드에 영향을 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성

항상 절차를 추상화하는 객체지향 설계 방식을 따라야 하는가? 추상 데이터 타입은 모든 경우에 최악의 선택인가??

> 새로운 타입을 빈번하게 추가해야 한다면 객체지향의 클래스 구조가 더 유용하지만 새로운 오퍼레이션을 빈번하게 추가해야 한다면 추상 데이터 타입을 선택하는게 현명하다

객체지향에서 중요한 것은 역할, 책임, 협력이다. 객체지향은 기능을 행하기 위해 객체들이 협력하는 방식에 집중한다. 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션의 구현 방식을 타입별로 분배하는 것은 올바른 접근법이 아니다.  # 협력이라는 것을 고려하지 않는다면 빈번한 수정이 예상이 된다..













