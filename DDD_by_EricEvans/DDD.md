##### VALUE OBJECT에 대하여

모델에 포함된 어떤 요소의 속성에만 관심이 있다면 그것을 value object로 분류해야 한다. value object가 전하는 속성의 의미를 표현하고 관련한 기능을 제공하면 좋다.  그리고 불변성을 유지하고 식별하는 것을 넣지 말아야 한다.

```
value object는 해당 요소가 어느 것인지는 관심없고 무엇인지에 대해서만 관심있게 해야 한다.
```



##### 여러 시스템 사이에서 객체의 공유가 사용해도 되는 경우

1. 공간을 절약하거나 데이터베이스 내에 객체 수를 줄이는 것이 중요한 경우
2. 통신 부하가 낮은 경우
    1. 공유 객체의 불변성이 엄격하게 지켜지는 경우

##### value object의 변경을 허락하는 경우

1.  값이 자주 바뀌는 경우
2. 객체 생성이나 삭제에 비용이 적게 드는 경우
3. 교체로 인해 클러스터링이 제한되는 경우 
4. value를 공유할 일이 그리 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 분류된 경우

#### value가 변경이 가능하면 그것을 공유하면 안된다.



##### 도메인 연산은 사물이 아닌 활동 or 행동인데 모델링 패러다임이 객체이므로 그러한 연산도 객체와 잘 어울리게끔 만들어야 한다

객체에 어울리지 않는 연산을 강제로 넣을 경우 객체는 자신의 개념적 명확성을 잃어버리고 이해하거나 리팩터링하기 어려워 진다. >> 객체에 대한 책임을 추가하는 것이고 객체에 대한 의존성을 만들어서 단독으로 이해할 수 있는 개념을 애매한 객체로 전락시킴

##### Service는 도메인과 관련된 연산을 하고 정의하는 기준은 클라이언트에 무엇을 제공할 수 있냐이다

서비스의 매개변수와 반환값은 도메인 객체여야함



#### 잘 만들어진 Service 특징

1. 연산이 원래부터 엔티티나 벨류의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다
2. 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의
3. 연산은 상태가 없다 > 클라리언트가 서비스의 모든 인스턴스를 사용할 수 있다는 것을 말함

##### 도메인의 중대한 프로세스나 변환 과정이 엔티티나 벨류의 고유한 책임이 아니라면 연산을 서비스로 선언되는 독립 인터페이스로 모델에 추가ㄱㄱ



서비스의 종류

1. 도메인 서비스
2. 응용서비스



### 모듈 Module

모듈 간에는 결합도가 낮아야하고 모듈 내부는 응집도가 높아야 한다

- 모듈의 이름은 모듈의 의미를 전달한다



도메인에는 도메인과 밀접한 연관된 요소만 넣는다.



#### 모델링 패러다임 p.120

패러다임으 ㄹ혼합하면 개발자들이 어떤 개념을 그것에 가장 잘 어울리는 형식으로 모델링 가능, 그렇지만 응집력있는 모델을 만드는 것은 쉽지가 않다. 개발자가 소프트웨어에 포함된 응집력 있는 모델을 분명하게 볼 수 없다면 다양한 패러다임이 혼재하는 시스템에서 모델 주도 설계의 의미는 희미해질 수 있다.



#### 패러다임이 혼재할 때 모델 주도 설계 고수하기

룰 엔진은 떄대로 객체지향 프로젝트에서 혼용되는 기술의 예이다. 도메인 모델에는 명시적인 규칙이 포함되어 있지만 그럼에도 여전히 객체 패러다임에는 규칙과 규칙 간의 상호작용을 나타내기 위한 구체적인 의미체계가 부족하다.

룰 엔진 기술이 좋은 이유는  규칙을 정의하는 자연스러운 선언적인 방식을 제공하기 때문이고 객체의 약점과 강점을 보충함

자연스러운 연결을 제공하는 환경이 없다면 전체 설계를 유지하고자 명확하고 근본적인 개념으로 구성된 모델을 정제하는 일은 개발자의 몫으로 된다



모델 주도 설계가 객체지향적일 필요는 없지만, 모델 주도 설계는 표현력이 풍부한 모델 구성물(객체나 규칙, 또는 워크플로)의 구현에 분명 의존한다. 



##### 객체가 아닌 요소를 객체지향 시스템에 혼합하는데 필요한 4가지 법칙

1. 구현 패러다임을 도메인에 억지로 맞추지 않는다. 도메인에 관한 사고방식은 반드시 하나만 있는 것이 아니다. 패러다임에 어울리는 모델 개념을 가짐
2. 유비쿼터스 언어에 의지함 > 각종 도구가 서로 엄밀한 관계에 있지 않더라도 언어를 매우 일관되게 사용하면 설계의 각 부분이 분화되는 것을 방지
3. UML에 심취하지 않는다
4. 회의적이어야 한다 



### 06. 도메인 객체의 생명주기 p.127

모든 객체에는 생명주기가 있다. 생명되어서 자기 할 일을 다하고 가비지 컬렉션에 의해 회수되어 사라지는 객체가 있기도 하고, 또 어떤 객체는 더 오래 지속되어 남는 객체들이 있다. 또한 여러가지 상태의 변화를 겪기도 하다.

도메인 객체의 관리와 관련된 문제는 아래의 두 가지 범주로 나뉜다.

1. 생명주기 동안의 무결성 유지
2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지



##### 이 책에서는 생명주기 관리 문제를 3가지로 관리

1. aggregate는 소유권과 경계를 명확히 정의 > 객체를 혼란스럽게 얽히지 않게함 > 이렇게 하는 것은 생명주기 상에서 도메인 무결성을 유지하는데 중요하다
2. 생명주기의 초기 단계로 초점을 바꿔 ㄹactory를 이용해 족잡한 객체와 aggregate를 생성하고 재구성함으로써 내부 구조를 캡슐화한다
3. 생명주기의 중간과 마지막을 다루고, 관련 인프라스트럭처를 캡술화하면서 영속 객체를 찾아 조회하는 수단을 제공하는 repository

Repository와 Factory는 도메인에서 중요하게 작용한다. 레포지토리와 팩토리는 도메인에 접근을 용이하게 하고 model driven design을 완성시킨다

Aggregate를 모델링하고 설계에 factory와 repository를 추가하면 모델 객체의 생명주기 동안 체계적이고 의미 있는 단위로 조작할 수 있다

###### Aggregate는 생명주기 전 단계에서 불변식을 유지해야할 범위를 표시함



### 불변식: 데이터가 변경될 때마다 유지해야하는 일관성 규칙

### aggregate

연관관계를 최소주의 관점에서 설계하면 탐색이 단순, 폭발적으로 증가하는 관계를 제한하는데 도움이된다. 하지만 대부분의 업무 도메인은 상호 연관의 정도가 높아서 객체 참조를 통해 얽힌 관계를 파악해야함



모델 내에서 복잡한 연관고나계를 맺는 객체를 배상으로 변경의 일관성을 보장하는 것은 어렵다. 그 이유는 개별 객체만이 아닌 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용돼야 하기 때문이다. 그렇다고 변경의 일관성을 보장하고자 신중 잠금 깁버을 쓴다면 다수의 사용자가 서로 부적절하게 간섭해서 시스템을 사용할 수 없는 상태가 된다.

##### 모델 내의 소유 관계를 저의하는 방법 > 단순하고 엄격한 체계

애그리거트는 우리가 데이터 변경의 단위로 다루는 **연관 객체**의 묶음을 말한다. 

**애그리거트의 경계** > 애그리거트에 무엇이 포함되고 포함되지 않는지를 정의함. 경계 안의 객체들은 서로를 참조할 수 있다. 하지만 경계 밖의 객체는 루트 애그리거트(경계 밖의 객체는 경계 안을 볼 수가 없어야함)만 참조할 수 있음.

**애그리거트의 루트** > 단 하나만 존재한다 애그리거트에 포함된 특정 엔티티를 가리킴



#####  애그리거트를 구현할 때 모든 트랜잭션에 적용되는 규칙

- 루트 엔티티는 전역 식별성을 지니고 궁극적으로 불변식을 검사할 책임이 있음
- 각 루트 엔티티는 전역 식별성을 지닌다. 경계 안의 엔티티는 지역 식별성을 지닌다(지역 식별성은 애그리거트 경계 안에서만 유효함)
- 애그리거트의 경계 밖에서는 애그리거트의 루트 이외에 경계 안의 엔티티를 참조할 수 없고, 루트 엔티티를 통해서만 참조할 수 있다. 
    - 루트 엔티티가 내부 엔티티의 참조를 일시적으로 제공할 수는 있지만, 참조를 계속 보유할 수는 없음
    - 루트 엔티티는 value object의 복사본을 제공할 수는 있지만 복사본에서 어떤 일이 일어나도 문제가 안됨. 단순의 value object이고 이는 애그리거트와는 더이상 관련이 없기 때문이다.
- 지금까지의 규칙의 바탕으로는 애그리거트의 루트만 참조할 수 있다. 내부 엔티티는 루트를 통해서만 접근이 가능하다 (이 부분은 인정할 수가 없다. 이렇게 된다면 불필요한 객체도 가져와야 하기 때문)
- 애그리거트의 안의 객체는 다른 애그리거트의 루트만 참조할 수 있다
- 삭제 연산은 애그리거트 경계 안의 모든 요소를 한 번에 제거할 수 있어야 한다. 
- 애그리거트 경계 안의 어떤 객체를 변경하더라도 전체 애그리거트의 불변식은 모두 지켜져야 한다.

```markdown
엔티티와 VO를 애그리거트로 모으고 각각에 대해 경계의 정의하라
루트 엔티티를 만들고, 애그리거트 경계 내부의 객체에 대해서는 루트를 거쳐 접근할 수 있게 하고 내부 엔티티는 루트 엔티티를 통해서만 접근가능하게 하고 외부를 통한 접근은 루트 엔티티를 통해서 접근하게 해야함
> 루트를 통하지 않고서는 내부를 변경할 수 없다.
```



클라이언트 객체가 도메인 객체에 의존하고 있다면 클라이언트 객체는 도메인 객체 내부 연산에 대해서 어느정도 이해하고 있는 것이며 도메인 객체의 각 구성요소의 관계에 적용되는 모든 불변식을 이행하려면 클라이언트 객체에서 도메인 객체의 불변식에 대해서 이해를 하고 있어야한다. >> 이렇게 되면 더욱더 리팩터링이 어려워진다.

###### 구현의 세부사항에 강하게 결합되면 도메인 게층을 추상화해서 얻을 수 있는 이점은 사라지고 이전보다 훨씬 더 많은 비용이 듦

##### 객체를 생성하는 것은 주요한 연산이 될 수도 있지만, 복잡한 조립 연산은 생성된 객체의 책임으로 어울리지 않는다. 이런 설계가 클라이언트 단에 존재하게 되면 이해하기 어려운 설계가 된다. 클라이언트에서 직접 생성하게 되면 클라이언트 설계가 지저분해지고 조립되는 객체나 애그리거트의 캡슐화를 위반된다.

> 복잡한 객체를 생성하는 일은 도메인 계층의 **책임** 



### Factory (팩토리)

어떤 객체나 전체 애그리거트를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러내는 경우 Factory를 통해서 캡슐화를 제공한다.

##### **팩토리** : 자신의 책임이 다른 객체를 생성하는 것, ex) OrderManageFactory



#### 팩토리를 잘 설계하기 위한 두 가지 기본 요건

1. 각 생성 방법은 원자적(atomic) 이어야함. 생성된 객체나 애그리거트의 불변식을 모두 지켜야함. 일관성 있는 상태에서만 객체를 생성할 수 있어야함. 엔티티의 경우 전체 애그리거트를 생성하는 것을 의미
2. 팩토리는 생성된 클래스보단느 생성하고자 하는 타입으로 추상화 되어야 한다.

```java
public class PurChaseOrder {
  
  public PurChaseItem newPurchaseItem() {
   	return new PurChaseItem();
  }
}
```

팩토리는 객체 내부에 있거나, 단독으로 facotry로 존재할 수 있다. xxxxFactory, 내부 객체일 떄는 create()와 같은 메서드로 존재

구상 클래스(concreate class) : 구상 클래스는 abstract class가 아닌 'class'를 의미함. 구상이라는 단어는 실제적이고 구체적이라는 뜻

#### 생성자만으로 충분한 경우 

- 클래스가 타입인 경우, 클래스가 어떤 계층 구조의 일부가 아니고, 인터페이스를 구현하는 식으로 다형적이지 않은 경우
- 클라이언트가 strategy를 선택하는 한 방법으로써 구현체에 관심이 있는 경우
- 클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지 않는 경우
- 생성자가 복잡하지 않은 경우
- 공개 생성자가 factory와 동일한 규칙을 반드시 준수해야 하는 경우 (이때 해당 규칙은 생성된 객체의 모든 불변식을 충족하는 원자적인 연산이어야함)



#### 인터페이스 설계

팩토리의 메서드를 설계할 때는 헤당 팩토르가 독립형이냐 팩토리 메서드냐에 따라 관계없이 다음의 두 가지 사항을 명심해야 한다.

1. 각 연산은 원자적이어야 한다.

    > 복잡한 생성물을 만드는데 필요한 매개변수를 모두 한 번에 factory로 전달해야 한다. 또한 실패할 경우에 어떻게 하는지 결정해야 하는데, 이 경우 **예외**를 던지거나 단순히 **null** 값을 반환할 수도 있다. 

2. 팩토리는 자신에게 전달된 인자와 결합될 것이다.

    > 입력 매개변수를 선택하는데 신경쓰지 않는 다면 의존성의 덫이 만들어질 수 있다. 결합의 정도는 인자를 어떻게 선택하느냐에 따라 달라진다. 인자가 단수히 생성물에 들어간느 것이라면 가장 의존성이 적당하다.

가장 안전한 매개변수를 하위 설계 계층에서 나오는 매개변수

##### 구상 클래스가 아닌 추상적인 타입의 인자를 사용하라. factory는 생성물의 구상 클래스에 결합되므로 구상 매개변수에도 결합될 필요는 없다.



#### 불변식 로직의 위치

factory의 책임은 factory가 만드는 객체나 애그리거트의 불변식이 충족되도록 보장하는 것이다. factory의 불변식 검사는 생성물에 위임할 수 있고, 이것이 최선일 때가 있다.

factory는 자신의 생성물과 특별한 관계를 맺는다. factory는 자신이 만들어 내는 생성물의 내부 구조를 이미 알고 있고, 팩토리의 존재 이유는 생성물에 대현 구현과 밀접하게 연관되어 있음. 

#### Entity Factory와 VO Factory

두가지의 다른 점은 vo는 생성물이 완전히 최종적인 형태로 만들어지기 때문에 불변이다. 그래서 factory는 생성물에 대해서 상세한 설명을 해야함

entity 팩토리는 애그리거트를 만들어 내는데 필요한 매개변수만 받아 들인다. 불변식에서 세부사항을 필요하지 않으면 나중에 추가 가능

​	

#### 정리

> factory는 객체의 생성과 재구성이라는 생명주기 전이를 캡슐화함. 도메인 설계를 난해하게 할 수 있는 기술적 복잡성을 노출하는 또 하나의 생명주기 전이로는 **저장소에 들어갈 때**와 **저장소에서 나올 때** 거치는 전이가 있음.

























































































































