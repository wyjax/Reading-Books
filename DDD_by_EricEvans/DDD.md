##### VALUE OBJECT에 대하여

모델에 포함된 어떤 요소의 속성에만 관심이 있다면 그것을 value object로 분류해야 한다. value object가 전하는 속성의 의미를 표현하고 관련한 기능을 제공하면 좋다.  그리고 불변성을 유지하고 식별하는 것을 넣지 말아야 한다.

```
value object는 해당 요소가 어느 것인지는 관심없고 무엇인지에 대해서만 관심있게 해야 한다.
```



##### 여러 시스템 사이에서 객체의 공유가 사용해도 되는 경우

1. 공간을 절약하거나 데이터베이스 내에 객체 수를 줄이는 것이 중요한 경우
2. 통신 부하가 낮은 경우
    1. 공유 객체의 불변성이 엄격하게 지켜지는 경우

##### value object의 변경을 허락하는 경우

1.  값이 자주 바뀌는 경우
2. 객체 생성이나 삭제에 비용이 적게 드는 경우
3. 교체로 인해 클러스터링이 제한되는 경우 
4. value를 공유할 일이 그리 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 분류된 경우

#### value가 변경이 가능하면 그것을 공유하면 안된다.



##### 도메인 연산은 사물이 아닌 활동 or 행동인데 모델링 패러다임이 객체이므로 그러한 연산도 객체와 잘 어울리게끔 만들어야 한다

객체에 어울리지 않는 연산을 강제로 넣을 경우 객체는 자신의 개념적 명확성을 잃어버리고 이해하거나 리팩터링하기 어려워 진다. >> 객체에 대한 책임을 추가하는 것이고 객체에 대한 의존성을 만들어서 단독으로 이해할 수 있는 개념을 애매한 객체로 전락시킴

##### Service는 도메인과 관련된 연산을 하고 정의하는 기준은 클라이언트에 무엇을 제공할 수 있냐이다

서비스의 매개변수와 반환값은 도메인 객체여야함



#### 잘 만들어진 Service 특징

1. 연산이 원래부터 엔티티나 벨류의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다
2. 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의
3. 연산은 상태가 없다 > 클라리언트가 서비스의 모든 인스턴스를 사용할 수 있다는 것을 말함

##### 도메인의 중대한 프로세스나 변환 과정이 엔티티나 벨류의 고유한 책임이 아니라면 연산을 서비스로 선언되는 독립 인터페이스로 모델에 추가ㄱㄱ



서비스의 종류

1. 도메인 서비스
2. 응용서비스



### 모듈 Module

모듈 간에는 결합도가 낮아야하고 모듈 내부는 응집도가 높아야 한다

- 모듈의 이름은 모듈의 의미를 전달한다



도메인에는 도메인과 밀접한 연관된 요소만 넣는다.



#### 모델링 패러다임 p.120

패러다임으 ㄹ혼합하면 개발자들이 어떤 개념을 그것에 가장 잘 어울리는 형식으로 모델링 가능, 그렇지만 응집력있는 모델을 만드는 것은 쉽지가 않다. 개발자가 소프트웨어에 포함된 응집력 있는 모델을 분명하게 볼 수 없다면 다양한 패러다임이 혼재하는 시스템에서 모델 주도 설계의 의미는 희미해질 수 있다.



#### 패러다임이 혼재할 때 모델 주도 설계 고수하기

룰 엔진은 떄대로 객체지향 프로젝트에서 혼용되는 기술의 예이다. 도메인 모델에는 명시적인 규칙이 포함되어 있지만 그럼에도 여전히 객체 패러다임에는 규칙과 규칙 간의 상호작용을 나타내기 위한 구체적인 의미체계가 부족하다.

룰 엔진 기술이 좋은 이유는  규칙을 정의하는 자연스러운 선언적인 방식을 제공하기 때문이고 객체의 약점과 강점을 보충함

자연스러운 연결을 제공하는 환경이 없다면 전체 설계를 유지하고자 명확하고 근본적인 개념으로 구성된 모델을 정제하는 일은 개발자의 몫으로 된다



모델 주도 설계가 객체지향적일 필요는 없지만, 모델 주도 설계는 표현력이 풍부한 모델 구성물(객체나 규칙, 또는 워크플로)의 구현에 분명 의존한다. 



##### 객체가 아닌 요소를 객체지향 시스템에 혼합하는데 필요한 4가지 법칙

1. 구현 패러다임을 도메인에 억지로 맞추지 않는다. 도메인에 관한 사고방식은 반드시 하나만 있는 것이 아니다. 패러다임에 어울리는 모델 개념을 가짐
2. 유비쿼터스 언어에 의지함 > 각종 도구가 서로 엄밀한 관계에 있지 않더라도 언어를 매우 일관되게 사용하면 설계의 각 부분이 분화되는 것을 방지
3. UML에 심취하지 않는다
4. 회의적이어야 한다 



### 06. 도메인 객체의 생명주기 p.127

모든 객체에는 생명주기가 있다. 생명되어서 자기 할 일을 다하고 가비지 컬렉션에 의해 회수되어 사라지는 객체가 있기도 하고, 또 어떤 객체는 더 오래 지속되어 남는 객체들이 있다. 또한 여러가지 상태의 변화를 겪기도 하다.

도메인 객체의 관리와 관련된 문제는 아래의 두 가지 범주로 나뉜다.

1. 생명주기 동안의 무결성 유지
2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지



##### 이 책에서는 생명주기 관리 문제를 3가지로 관리

1. aggregate는 소유권과 경계를 명확히 정의 > 객체를 혼란스럽게 얽히지 않게함 > 이렇게 하는 것은 생명주기 상에서 도메인 무결성을 유지하는데 중요하다
2. 생명주기의 초기 단계로 초점을 바꿔 ㄹactory를 이용해 족잡한 객체와 aggregate를 생성하고 재구성함으로써 내부 구조를 캡슐화한다
3. 생명주기의 중간과 마지막을 다루고, 관련 인프라스트럭처를 캡술화하면서 영속 객체를 찾아 조회하는 수단을 제공하는 repository

Repository와 Factory는 도메인에서 중요하게 작용한다. 레포지토리와 팩토리는 도메인에 접근을 용이하게 하고 model driven design을 완성시킨다

Aggregate를 모델링하고 설계에 factory와 repository를 추가하면 모델 객체의 생명주기 동안 체계적이고 의미 있는 단위로 조작할 수 있다

###### Aggregate는 생명주기 전 단계에서 불변식을 유지해야할 범위를 표시함



### 불변식: 데이터가 변경될 때마다 유지해야하는 일관성 규칙

### aggregate

연관관계를 최소주의 관점에서 설계하면 탐색이 단순, 폭발적으로 증가하는 관계를 제한하는데 도움이된다. 하지만 대부분의 업무 도메인은 상호 연관의 정도가 높아서 객체 참조를 통해 얽힌 관계를 파악해야함



모델 내에서 복잡한 연관고나계를 맺는 객체를 배상으로 변경의 일관성을 보장하는 것은 어렵다. 그 이유는 개별 객체만이 아닌 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용돼야 하기 때문이다. 그렇다고 변경의 일관성을 보장하고자 신중 잠금 깁버을 쓴다면 다수의 사용자가 서로 부적절하게 간섭해서 시스템을 사용할 수 없는 상태가 된다.

##### 모델 내의 소유 관계를 저의하는 방법 > 단순하고 엄격한 체계

애그리거트는 우리가 데이터 변경의 단위로 다루는 **연관 객체**의 묶음을 말한다. 

**애그리거트의 경계** > 애그리거트에 무엇이 포함되고 포함되지 않는지를 정의함. 경계 안의 객체들은 서로를 참조할 수 있다. 하지만 경계 밖의 객체는 루트 애그리거트(경계 밖의 객체는 경계 안을 볼 수가 없어야함)만 참조할 수 있음.

**애그리거트의 루트** > 단 하나만 존재한다 애그리거트에 포함된 특정 엔티티를 가리킴



#####  애그리거트를 구현할 때 모든 트랜잭션에 적용되는 규칙

- 루트 엔티티는 전역 식별성을 지니고 궁극적으로 불변식을 검사할 책임이 있음
- 각 루트 엔티티는 전역 식별성을 지닌다. 경계 안의 엔티티는 지역 식별성을 지닌다(지역 식별성은 애그리거트 경계 안에서만 유효함)
- 애그리거트의 경계 밖에서는 애그리거트의 루트 이외에 경계 안의 엔티티를 참조할 수 없고, 루트 엔티티를 통해서만 참조할 수 있다. 
    - 루트 엔티티가 내부 엔티티의 참조를 일시적으로 제공할 수는 있지만, 참조를 계속 보유할 수는 없음
    - 루트 엔티티는 value object의 복사본을 제공할 수는 있지만 복사본에서 어떤 일이 일어나도 문제가 안됨. 단순의 value object이고 이는 애그리거트와는 더이상 관련이 없기 때문이다.
- 지금까지의 규칙의 바탕으로는 애그리거트의 루트만 참조할 수 있다. 내부 엔티티는 루트를 통해서만 접근이 가능하다 (이 부분은 인정할 수가 없다. 이렇게 된다면 불필요한 객체도 가져와야 하기 때문)
- 애그리거트의 안의 객체는 다른 애그리거트의 루트만 참조할 수 있다
- 삭제 연산은 애그리거트 경계 안의 모든 요소를 한 번에 제거할 수 있어야 한다. 
- 애그리거트 경계 안의 어떤 객체를 변경하더라도 전체 애그리거트의 불변식은 모두 지켜져야 한다.

```markdown
엔티티와 VO를 애그리거트로 모으고 각각에 대해 경계의 정의하라
루트 엔티티를 만들고, 애그리거트 경계 내부의 객체에 대해서는 루트를 거쳐 접근할 수 있게 하고 내부 엔티티는 루트 엔티티를 통해서만 접근가능하게 하고 외부를 통한 접근은 루트 엔티티를 통해서 접근하게 해야함
> 루트를 통하지 않고서는 내부를 변경할 수 없다.
```



클라이언트 객체가 도메인 객체에 의존하고 있다면 클라이언트 객체는 도메인 객체 내부 연산에 대해서 어느정도 이해하고 있는 것이며 도메인 객체의 각 구성요소의 관계에 적용되는 모든 불변식을 이행하려면 클라이언트 객체에서 도메인 객체의 불변식에 대해서 이해를 하고 있어야한다. >> 이렇게 되면 더욱더 리팩터링이 어려워진다.

###### 구현의 세부사항에 강하게 결합되면 도메인 게층을 추상화해서 얻을 수 있는 이점은 사라지고 이전보다 훨씬 더 많은 비용이 듦

##### 객체를 생성하는 것은 주요한 연산이 될 수도 있지만, 복잡한 조립 연산은 생성된 객체의 책임으로 어울리지 않는다. 이런 설계가 클라이언트 단에 존재하게 되면 이해하기 어려운 설계가 된다. 클라이언트에서 직접 생성하게 되면 클라이언트 설계가 지저분해지고 조립되는 객체나 애그리거트의 캡슐화를 위반된다.

> 복잡한 객체를 생성하는 일은 도메인 계층의 **책임** 



### Factory (팩토리)

어떤 객체나 전체 애그리거트를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러내는 경우 Factory를 통해서 캡슐화를 제공한다.

##### **팩토리** : 자신의 책임이 다른 객체를 생성하는 것, ex) OrderManageFactory



#### 팩토리를 잘 설계하기 위한 두 가지 기본 요건

1. 각 생성 방법은 원자적(atomic) 이어야함. 생성된 객체나 애그리거트의 불변식을 모두 지켜야함. 일관성 있는 상태에서만 객체를 생성할 수 있어야함. 엔티티의 경우 전체 애그리거트를 생성하는 것을 의미
2. 팩토리는 생성된 클래스보단느 생성하고자 하는 타입으로 추상화 되어야 한다.

```java
public class PurChaseOrder {
  
  public PurChaseItem newPurchaseItem() {
   	return new PurChaseItem();
  }
}
```

팩토리는 객체 내부에 있거나, 단독으로 facotry로 존재할 수 있다. xxxxFactory, 내부 객체일 떄는 create()와 같은 메서드로 존재

구상 클래스(concreate class) : 구상 클래스는 abstract class가 아닌 'class'를 의미함. 구상이라는 단어는 실제적이고 구체적이라는 뜻

#### 생성자만으로 충분한 경우 

- 클래스가 타입인 경우, 클래스가 어떤 계층 구조의 일부가 아니고, 인터페이스를 구현하는 식으로 다형적이지 않은 경우
- 클라이언트가 strategy를 선택하는 한 방법으로써 구현체에 관심이 있는 경우
- 클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지 않는 경우
- 생성자가 복잡하지 않은 경우
- 공개 생성자가 factory와 동일한 규칙을 반드시 준수해야 하는 경우 (이때 해당 규칙은 생성된 객체의 모든 불변식을 충족하는 원자적인 연산이어야함)



#### 인터페이스 설계

팩토리의 메서드를 설계할 때는 헤당 팩토르가 독립형이냐 팩토리 메서드냐에 따라 관계없이 다음의 두 가지 사항을 명심해야 한다.

1. 각 연산은 원자적이어야 한다.

    > 복잡한 생성물을 만드는데 필요한 매개변수를 모두 한 번에 factory로 전달해야 한다. 또한 실패할 경우에 어떻게 하는지 결정해야 하는데, 이 경우 **예외**를 던지거나 단순히 **null** 값을 반환할 수도 있다. 

2. 팩토리는 자신에게 전달된 인자와 결합될 것이다.

    > 입력 매개변수를 선택하는데 신경쓰지 않는 다면 의존성의 덫이 만들어질 수 있다. 결합의 정도는 인자를 어떻게 선택하느냐에 따라 달라진다. 인자가 단수히 생성물에 들어간느 것이라면 가장 의존성이 적당하다.

가장 안전한 매개변수를 하위 설계 계층에서 나오는 매개변수

##### 구상 클래스가 아닌 추상적인 타입의 인자를 사용하라. factory는 생성물의 구상 클래스에 결합되므로 구상 매개변수에도 결합될 필요는 없다.



#### 불변식 로직의 위치

factory의 책임은 factory가 만드는 객체나 애그리거트의 불변식이 충족되도록 보장하는 것이다. factory의 불변식 검사는 생성물에 위임할 수 있고, 이것이 최선일 때가 있다.

factory는 자신의 생성물과 특별한 관계를 맺는다. factory는 자신이 만들어 내는 생성물의 내부 구조를 이미 알고 있고, 팩토리의 존재 이유는 생성물에 대현 구현과 밀접하게 연관되어 있음. 

#### Entity Factory와 VO Factory

두가지의 다른 점은 vo는 생성물이 완전히 최종적인 형태로 만들어지기 때문에 불변이다. 그래서 factory는 생성물에 대해서 상세한 설명을 해야함

entity 팩토리는 애그리거트를 만들어 내는데 필요한 매개변수만 받아 들인다. 불변식에서 세부사항을 필요하지 않으면 나중에 추가 가능

​	

#### 정리

> factory는 객체의 생성과 재구성이라는 생명주기 전이를 캡슐화함. 도메인 설계를 난해하게 할 수 있는 기술적 복잡성을 노출하는 또 하나의 생명주기 전이로는 **저장소에 들어갈 때**와 **저장소에서 나올 때** 거치는 전이가 있음.



### Repository

entity나 value를 탐색하기 위한 진입점을 위해 존재

데이터베이스는 어떤 객체에도 접근하게 해준다. 하지만 모든 객체가 상호 연결되어 있을 필요는 없음

연관관계의 응집력과 검색의 분리는 상충하다.



도메인 주도 설계의 목표는 기술보다는 도메인에 대한 모델에 집중해 더 나은 소프트웨어를 만드는 것

영속 객체는 해당 객체의 속성에 근거해서 검색하는 식으로 전역적으로 접근할 수 있어야한다. 이러한 접근 방식은 필요한 곳은 일반적으로 **루트 엔티티**이다. 

Repository를 통해서 객체를 재구성 하는 것은 Factory와 같이 복잡성을 감추는데 이바지함

> Repository는 데이터를 조회하는 것을 캡슐화해서 우리가 모델에 집중할 수 있게 해준다

##### 객체의 생명주기의 시작과 끝에까지 이르기까지 애그리거트의 루트에 대한 접근을 제공하는 응집력있는 책임이 포함된다



전역적인 접근이 필요할 경우. 전역 인터페이스를 토대로 한 접근 방법을 고안해야 한다. 객체를 추가하고 제거하는 메서드를 제공하고, 이 메서드가 실제로 데이터를 저장소에 데이터를 저장하고 삭제하는 연산을 캡슐화하게 하라. 조회시 단수 객체나 복수 객체를 반환하도록 제공함으로써 실제 저장소와 질의 기술을 캡슐화 해야 한다.

##### 위와 같이 함으로써 애그리거트의 루트에 대해서만 repository를 제공하고 모든 객체의 저장과 접근은 repository에 위임해서 클라이언트가 모델이 집중하게 된다.

> JPA나 mybatis 같은 경우가 이런 경우이다. 인터페이스를 통해서 객체의 조회, 저장, 삭제를 제공함

#### Repository 이점

- 영속화된 객체를 획득하고 해당 객체의 생명주기를 관리하기 위한 단순한 모델을 클라이언트에 제공
- 영속화 기술과 다수의 데이터베이스 전략, 또는 심지어 다수의 데이터 소스로부터 애플리케이션과 도메인 설계를 분리해준다.
- 객체 접근에 대한 설계 결정을 제공
- 테스트에서 사용할 가짜 구현을 손쉽게 대체 가능하다



#### 클라이언트 코드가 Repository 구현을 무시한다

개발자는 캡슐화가 되어 있는 부분을 항상 알고 있어야함. 구현상의 상세한 내용까지 알아야 하는 것은 아니고 특징을 알면 된다.



##### Repository 구현

구현은 영속화에 사용되느 기술과 인프라에 따라 매우 다양해진다. 저장, 조회, 질의 메커니즘을 캡슐화하는 것은 Repository 구현의 가장 기본적인 기능

- 타입을 추상화한다. > 추상화하지 않으면 다형성이 존재하지 않아서 발생할 수 있는 제약조건에 마주치게 된다.
- 클라이언트와의 분리를 활용한다. 클라이언트에서 직접 메커니즘을 호출했을 때보다 더 자유롭게 repository의 구현을 변경할 수 있다.
- **트랜잭션 제어를 클라이언트에 둔다.** 삽입과 삭제는 db에서 수행하겠지만 repository에서는 아무것도 커밋하지 않을 것이다. 

#### Factory와의 관계

Factory가 객체 생애의 초기 단계를 다루는 데 반해 repsitory는 중간 단계와 마지막 단계를 관리하는데 도움된다. 객체가 메모리에 상주하거나 객체 데이터베이스에 저장돼 있을 때는 객체를 다루기가 매우 쉽다.

도메인 주도 관점에서는 factory와 repository의 책임이 뚜렷하게 구분이됨 > factory는 새로운 객체를 만들어냄, repository는 기존 객체를 찾아냄

##### Factory와 Repository를 결합하는 이유?

"찾아서 없으면 새로 생성" 클라이언트가 객체를 찾고 없으면 새로 만드는 것은 자제해야하는 기능이다. 기껐해야 편리만 해지는 기능이기 때문 





































































































